#include <sys/socket.h>

#include <errno.h>
#include <unistd.h>

#include <memory>
#include <thread>

#include <arpc++/arpc++.h>
#include <gtest/gtest.h>
#include <argdata.hpp>

#include "server_test_proto.h"

TEST(Server, EndOfFile) {
  // Close one half of a socket pair. Reading requests should return
  // end-of-file, which is encoded as -1.
  int fds[2];
  EXPECT_EQ(0, socketpair(AF_UNIX, SOCK_STREAM, 0, fds));
  EXPECT_EQ(0, close(fds[0]));

  arpc::ServerBuilder builder(std::make_shared<arpc::FileDescriptor>(fds[1]));
  EXPECT_EQ(-1, builder.Build()->HandleRequest());
}

TEST(Server, BadMessage) {
  // A single byte does not correspond with a single message. The error
  // EBADMSG generated by the Argdata reader should propagate.
  int fds[2];
  EXPECT_EQ(0, socketpair(AF_UNIX, SOCK_STREAM, 0, fds));
  EXPECT_EQ(1, write(fds[0], "a", 1));
  EXPECT_EQ(0, close(fds[0]));

  arpc::ServerBuilder builder(std::make_shared<arpc::FileDescriptor>(fds[1]));
  EXPECT_EQ(EBADMSG, builder.Build()->HandleRequest());
}

TEST(Server, InvalidOperation) {
  // Writing some garbage Argdata should make the server return EOPNOTSUPP.
  // TODO(ed): Should this just return an error to the client?
  int fds[2];
  EXPECT_EQ(0, socketpair(AF_UNIX, SOCK_STREAM, 0, fds));
  std::unique_ptr<argdata_writer_t> writer = argdata_writer_t::create();
  writer->set(argdata_t::null());
  EXPECT_EQ(0, writer->push(fds[0]));
  EXPECT_EQ(0, close(fds[0]));

  arpc::ServerBuilder builder(std::make_shared<arpc::FileDescriptor>(fds[1]));
  EXPECT_EQ(EOPNOTSUPP, builder.Build()->HandleRequest());
}

TEST(Server, ServiceNotRegistered) {
  // Invoke an RPC on a server that has no services registered. Any RPC
  // should fail with UNIMPLEMENTED to indicate the service's absence.
  int fds[2];
  EXPECT_EQ(0, socketpair(AF_UNIX, SOCK_STREAM, 0, fds));
  std::shared_ptr<arpc::Channel> channel =
      arpc::CreateChannel(std::make_shared<arpc::FileDescriptor>(fds[0]));
  std::unique_ptr<server_test_proto::Service::Stub> stub =
      server_test_proto::Service::NewStub(channel);
  std::thread caller([&stub]() {
    arpc::ClientContext context;
    server_test_proto::Input input;
    server_test_proto::Output output;
    arpc::Status status = stub->UnaryCall(&context, input, &output);
    EXPECT_EQ(arpc::StatusCode::UNIMPLEMENTED, status.error_code());
    EXPECT_EQ("Service not registered", status.error_message());
  });

  arpc::ServerBuilder builder(std::make_shared<arpc::FileDescriptor>(fds[1]));
  EXPECT_EQ(0, builder.Build()->HandleRequest());
  caller.join();
}

// Simple service that does nothing more than echoing responses.
namespace {
class EchoService final : public server_test_proto::Service::Service {
 public:
  arpc::Status UnaryCall(arpc::ServerContext* context,
                         const server_test_proto::Input* request,
                         server_test_proto::Output* response) {
    response->set_text(request->text());
    response->set_file_descriptor(request->file_descriptor());
    return arpc::Status::OK;
  }
};
}

TEST(Server, UnaryEcho) {
  // Invoke RPCs on the EchoService and check whether the input text
  // properly ends up in the output.
  int fds[2];
  EXPECT_EQ(0, socketpair(AF_UNIX, SOCK_STREAM, 0, fds));
  std::shared_ptr<arpc::Channel> channel =
      arpc::CreateChannel(std::make_shared<arpc::FileDescriptor>(fds[0]));
  std::unique_ptr<server_test_proto::Service::Stub> stub =
      server_test_proto::Service::NewStub(channel);
  std::thread caller([&stub]() {
    arpc::ClientContext context;
    server_test_proto::Input input;
    server_test_proto::Output output;

    input.set_text("Hello, world!");
    EXPECT_TRUE(stub->UnaryCall(&context, input, &output).ok());
    EXPECT_EQ("Hello, world!", output.text());

    input.set_text("Goodbye, world!");
    EXPECT_TRUE(stub->UnaryCall(&context, input, &output).ok());
    EXPECT_EQ("Goodbye, world!", output.text());
  });

  arpc::ServerBuilder builder(std::make_shared<arpc::FileDescriptor>(fds[1]));
  EchoService service;
  builder.RegisterService(&service);
  std::shared_ptr<arpc::Server> server = builder.Build();
  EXPECT_EQ(0, server->HandleRequest());
  EXPECT_EQ(0, server->HandleRequest());
  caller.join();
  EXPECT_EQ(0, close(fds[0]));
}

TEST(Server, UnaryFileDesciptorPassing) {
  // Use the EchoService to pass a file descriptor back to us.
  int fds[2];
  EXPECT_EQ(0, socketpair(AF_UNIX, SOCK_STREAM, 0, fds));
  std::shared_ptr<arpc::Channel> channel =
      arpc::CreateChannel(std::make_shared<arpc::FileDescriptor>(fds[0]));
  std::unique_ptr<server_test_proto::Service::Stub> stub =
      server_test_proto::Service::NewStub(channel);
  std::thread caller([&stub]() {
    arpc::ClientContext context;
    server_test_proto::Input input;
    server_test_proto::Output output;

    // Write something into the pipe and send the read side to the
    // EchoService.
    int pfds[2];
    EXPECT_EQ(0, pipe(pfds));
    EXPECT_EQ(5, write(pfds[1], "Hello", 5));
    EXPECT_EQ(0, close(pfds[1]));
    input.set_file_descriptor(std::make_shared<arpc::FileDescriptor>(pfds[0]));
    EXPECT_TRUE(stub->UnaryCall(&context, input, &output).ok());

    // Original message should still be contained in the pipe.
    char buf[6];
    EXPECT_EQ(5, read(output.file_descriptor()->get(), buf, sizeof(buf)));
    ASSERT_EQ("Hello", std::string_view(buf, 5));
  });

  arpc::ServerBuilder builder(std::make_shared<arpc::FileDescriptor>(fds[1]));
  EchoService service;
  builder.RegisterService(&service);
  std::shared_ptr<arpc::Server> server = builder.Build();
  EXPECT_EQ(0, server->HandleRequest());
  caller.join();
}
