#include <sys/socket.h>

#include <errno.h>
#include <unistd.h>
#include <argdata.hpp>

#include <memory>
#include <thread>

#include <arpc++/arpc++.h>
#include <gtest/gtest.h>

#include "server_test_proto.h"

TEST(Server, BadFileDescriptor) {
  // Attempting to use a bad file descriptor should trigger EBADF.
  arpc::ServerBuilder builder(-1);
  EXPECT_EQ(EBADF, builder.Build()->HandleRequest());
}

TEST(Server, EndOfFile) {
  // Close one half of a socket pair. Reading requests should return
  // end-of-file, which is encoded as -1.
  int fds[2];
  EXPECT_EQ(0, socketpair(AF_UNIX, SOCK_STREAM, 0, fds));
  EXPECT_EQ(0, close(fds[0]));

  arpc::ServerBuilder builder(fds[1]);
  EXPECT_EQ(-1, builder.Build()->HandleRequest());
  EXPECT_EQ(0, close(fds[1]));
}

TEST(Server, BadMessage) {
  // A single byte does not correspond with a single message. The error
  // EBADMSG generated by the Argdata reader should propagate.
  int fds[2];
  EXPECT_EQ(0, socketpair(AF_UNIX, SOCK_STREAM, 0, fds));
  EXPECT_EQ(1, write(fds[0], "a", 1));
  EXPECT_EQ(0, close(fds[0]));

  arpc::ServerBuilder builder(fds[1]);
  EXPECT_EQ(EBADMSG, builder.Build()->HandleRequest());
  EXPECT_EQ(0, close(fds[1]));
}

TEST(Server, InvalidOperation) {
  // Writing some garbage Argdata should make the server return EOPNOTSUPP.
  // TODO(ed): Should this just return an error to the client?
  int fds[2];
  EXPECT_EQ(0, socketpair(AF_UNIX, SOCK_STREAM, 0, fds));
  std::unique_ptr<argdata_writer_t> writer = argdata_writer_t::create();
  writer->set(argdata_t::null());
  EXPECT_EQ(0, writer->push(fds[0]));

  arpc::ServerBuilder builder(fds[1]);
  EXPECT_EQ(EOPNOTSUPP, builder.Build()->HandleRequest());

  EXPECT_EQ(0, close(fds[0]));
  EXPECT_EQ(0, close(fds[1]));
}

TEST(Server, ServiceNotRegistered) {
  // Invoke an RPC on a server that has no services registered. Any RPC
  // should fail with UNIMPLEMENTED to indicate the service's absence.
  int fds[2];
  EXPECT_EQ(0, socketpair(AF_UNIX, SOCK_STREAM, 0, fds));
  std::shared_ptr<arpc::Channel> channel = arpc::CreateChannel(fds[0]);
  std::unique_ptr<server_test_proto::Service::Stub> stub =
      server_test_proto::Service::NewStub(channel);
  std::thread caller([&stub]() {
    arpc::ClientContext context;
    server_test_proto::Input input;
    server_test_proto::Output output;
    arpc::Status status = stub->UnaryCall(&context, input, &output);
    EXPECT_EQ(arpc::StatusCode::UNIMPLEMENTED, status.error_code());
    EXPECT_EQ("Service not registered", status.error_message());
  });

  arpc::ServerBuilder builder(fds[1]);
  EXPECT_EQ(0, builder.Build()->HandleRequest());
  caller.join();

  EXPECT_EQ(0, close(fds[0]));
  EXPECT_EQ(0, close(fds[1]));
}

// Simple service that does nothing more than echoing responses.
namespace {
class EchoService final : public server_test_proto::Service::Service {
 public:
  arpc::Status UnaryCall(arpc::ServerContext* context,
                         const server_test_proto::Input* request,
                         server_test_proto::Output* response) {
    response->set_text(request->text());
    return arpc::Status::OK;
  }
};
}

TEST(Server, UnaryEcho) {
  // Invoke RPCs on the EchoService and check whether the input text
  // properly ends up in the output.
  int fds[2];
  EXPECT_EQ(0, socketpair(AF_UNIX, SOCK_STREAM, 0, fds));
  std::shared_ptr<arpc::Channel> channel = arpc::CreateChannel(fds[0]);
  std::unique_ptr<server_test_proto::Service::Stub> stub =
      server_test_proto::Service::NewStub(channel);
  std::thread caller([&stub]() {
    arpc::ClientContext context;
    server_test_proto::Input input;
    server_test_proto::Output output;

    input.set_text("Hello, world!");
    ASSERT_TRUE(stub->UnaryCall(&context, input, &output).ok());
    ASSERT_EQ("Hello, world!", output.text());

    input.set_text("Goodbye, world!");
    ASSERT_TRUE(stub->UnaryCall(&context, input, &output).ok());
    ASSERT_EQ("Goodbye, world!", output.text());
  });

  arpc::ServerBuilder builder(fds[1]);
  EchoService service;
  builder.RegisterService(&service);
  std::shared_ptr<arpc::Server> server = builder.Build();
  EXPECT_EQ(0, server->HandleRequest());
  EXPECT_EQ(0, server->HandleRequest());
  caller.join();

  EXPECT_EQ(0, close(fds[0]));
  EXPECT_EQ(0, close(fds[1]));
}
