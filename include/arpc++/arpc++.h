// Copyright (c) 2017 Nuxi (https://nuxi.nl/) and contributors.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
// FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
// DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
// OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
// HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
// LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
// OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
// SUCH DAMAGE.

#ifndef ARPCXX_ARPCXX_H
#define ARPCXX_ARPCXX_H

#include <unistd.h>

#include <cassert>
#include <forward_list>
#include <map>
#include <memory>
#include <set>
#include <string>
#include <string_view>
#include <type_traits>
#include <utility>

#include <argdata.hpp>

namespace arpc {

class ClientContext;
class ServerContext;
class ServerReaderImpl;
class ServerWriterImpl;

// RAII-style class for automatically closing a file descriptor. This
// class is used by ARPC to ensure that file descriptors that are
// attached to messages and transmitted have a proper lifetime.
class FileDescriptor {
 public:
  explicit FileDescriptor(int fd) : fd_(fd) {
    assert(fd >= 0 && "Attempted to create invalid file descriptor object");
  }

  ~FileDescriptor() {
    close(fd_);
  }

  int get() const {
    return fd_;
  }

 private:
  FileDescriptor(FileDescriptor const&) = delete;
  void operator=(FileDescriptor const& x) = delete;

  int fd_;
};

// Helper class that tracks conversion state when converting an
// argdata_t to a message class generated by aprotoc. This class keeps
// track of file descriptor objects, so that multiple references to the
// same file descriptor in the argdata_t can be converted to the same
// file descriptor object. It may also store argdata_t iterators to make
// google.protobuf.Any fields work.
class ArgdataParser {
 public:
  explicit ArgdataParser(argdata_reader_t* reader = nullptr);
  ~ArgdataParser();

  const argdata_t* ParseAnyFromMap(const argdata_map_iterator_t& it);
  std::shared_ptr<FileDescriptor> ParseFileDescriptor(const argdata_t& ad);

 private:
  // Comparator for finding file descriptors in a set of shared pointers
  // to FileDescriptor objects.
  class FileDescriptorComparator {
   public:
    using is_transparent = std::true_type;

    bool operator()(const std::shared_ptr<FileDescriptor>& a,
                    const std::shared_ptr<FileDescriptor>& b) const {
      return a->get() < b->get();
    }
    bool operator()(int a, const std::shared_ptr<FileDescriptor>& b) const {
      return a < b->get();
    }
    bool operator()(const std::shared_ptr<FileDescriptor>& a, int b) const {
      return a->get() < b;
    }
  };

  argdata_reader_t* const reader_;
  std::set<std::shared_ptr<FileDescriptor>, FileDescriptorComparator>
      file_descriptors_;
  std::forward_list<argdata_map_iterator_t> maps_;
};

// Allocator for temporary argdata_t objects. This class is used when
// serializing a message class generated by aprotoc to an argdata_t to
// store all of the temporarily allocated argdata_t objects. It can
// safely be destroyed after transmitting the resulting argdata_t.
class ArgdataBuilder {
 public:
  const argdata_t* BuildFd(const std::shared_ptr<FileDescriptor>& value);
  const argdata_t* BuildMap(std::vector<const argdata_t*> keys,
                            std::vector<const argdata_t*> values);
  const argdata_t* BuildSeq(std::vector<const argdata_t*> elements);
  const argdata_t* BuildStr(std::string_view value);

  template <typename T>
  const argdata_t* BuildInt(T value) {
    return argdatas_.emplace_back(argdata_create_int(value)).get();
  }

 private:
  std::vector<std::unique_ptr<argdata_t>> argdatas_;
  std::vector<std::shared_ptr<FileDescriptor>> file_descriptors_;
  std::forward_list<std::string> strings_;
  std::forward_list<std::vector<const argdata_t*>> vectors_;
};

// Base class for all message classes generated by aprotoc.
class Message {
 public:
  virtual ~Message() {
  }

  virtual const argdata_t* Build(ArgdataBuilder* argdata_builder) const = 0;
  virtual void Clear() = 0;
  virtual void Parse(const argdata_t& ad, ArgdataParser* argdata_parser) = 0;
};

enum class StatusCode {
  UNKNOWN,
  ABORTED,
  ALREADY_EXISTS,
  CANCELLED,
  DATA_LOSS,
  DEADLINE_EXCEEDED,
  FAILED_PRECONDITION,
  INTERNAL,
  INVALID_ARGUMENT,
  NOT_FOUND,
  OK,
  OUT_OF_RANGE,
  PERMISSION_DENIED,
  RESOURCE_EXHAUSTED,
  UNAUTHENTICATED,
  UNAVAILABLE,
  UNIMPLEMENTED,
  // Don't use this one. This is to force users to include a default branch.
  DO_NOT_USE = -1
};

// Simple error code and message class returned by the ARPC API.
class Status {
 public:
  Status() : code_(StatusCode::OK) {
  }

  Status(StatusCode code, std::string_view message)
      : code_(code), message_(message) {
  }

  StatusCode error_code() const {
    return code_;
  }

  const std::string& error_message() const {
    return message_;
  }

  bool ok() const {
    return code_ == StatusCode::OK;
  }

  static const Status OK;

 private:
  StatusCode code_;
  std::string message_;
};

// RPCs are uniquely identified by the service and function call name.
typedef std::pair<std::string_view, std::string_view> RpcMethod;

// Base class for all services generated by aprotoc.
class Service {
 public:
  virtual std::string_view GetName() = 0;
  virtual Status BlockingUnaryCall(std::string_view rpc, ServerContext* context,
                                   const argdata_t& request,
                                   ArgdataParser* argdata_parser,
                                   const argdata_t** response,
                                   ArgdataBuilder* argdata_builder) = 0;
  virtual Status BlockingClientStreamingCall(
      std::string_view rpc, ServerContext* context, ServerReaderImpl* reader,
      const argdata_t** response, ArgdataBuilder* argdata_builder) = 0;
  virtual Status BlockingServerStreamingCall(std::string_view rpc,
                                             ServerContext* context,
                                             const argdata_t& request,
                                             ArgdataParser* argdata_parser,
                                             ServerWriterImpl* writer) = 0;
};

// ARPC client.
class Channel {
 public:
  explicit Channel(const std::shared_ptr<FileDescriptor>& fd) : fd_(fd) {
  }

  Status BlockingUnaryCall(const RpcMethod& method, ClientContext* context,
                           const Message& request, Message* response);
  Status FinishUnaryResponse(Message* response);

  const std::shared_ptr<FileDescriptor>& GetFileDescriptor() {
    return fd_;
  }

 private:
  const std::shared_ptr<FileDescriptor> fd_;
};

std::shared_ptr<Channel> CreateChannel(
    const std::shared_ptr<FileDescriptor>& fd);

class ClientContext {};

// Client-side handle for server-streaming RPCs.
class ClientReaderImpl {
 public:
  ClientReaderImpl(Channel* channel, const RpcMethod& method,
                   ClientContext* context, const Message& request);
  ~ClientReaderImpl();

  Status Finish();
  bool Read(Message* msg);

 private:
  const std::shared_ptr<FileDescriptor> fd_;
  Status status_;
  bool finished_;
};

// Type safe wrapper for ClientReaderImpl.
template <typename R>
class ClientReader {
 public:
  template <typename W>
  ClientReader(Channel* channel, const RpcMethod& method,
               ClientContext* context, const W& request)
      : impl_(channel, method, context, request) {
  }

  Status Finish() {
    return impl_.Finish();
  }

  bool Read(R* msg) {
    return impl_.Read(msg);
  }

 private:
  ClientReaderImpl impl_;
};

// Client-side handle for client-streaming RPCs.
class ClientWriterImpl {
 public:
  ClientWriterImpl(Channel* channel, const RpcMethod& method,
                   ClientContext* context, Message* response);
  ~ClientWriterImpl();

  Status Finish();
  bool Write(const Message& msg);
  bool WritesDone();

 private:
  Channel* const channel_;
  Message* const response_;
  Status status_;
  bool writes_done_;
};

// Type safe wrapper for ClientWriterImpl.
template <typename W>
class ClientWriter {
 public:
  template <typename R>
  ClientWriter(Channel* channel, const RpcMethod& method,
               ClientContext* context, R* response)
      : impl_(channel, method, context, response) {
  }

  Status Finish() {
    return impl_.Finish();
  }

  bool Write(const W& msg) {
    return impl_.Write(msg);
  }

  bool WritesDone() {
    return impl_.WritesDone();
  }

 private:
  ClientWriterImpl impl_;
};

// ARPC server.
class Server {
 public:
  Server(const std::shared_ptr<FileDescriptor>& fd,
         const std::map<std::string, Service*, std::less<>>& services)
      : fd_(fd), services_(services) {
  }

  int HandleRequest();

 private:
  const std::shared_ptr<FileDescriptor> fd_;
  const std::map<std::string, Service*, std::less<>> services_;
};

// ARPC server factory.
class ServerBuilder {
 public:
  ServerBuilder(const std::shared_ptr<FileDescriptor>& fd) : fd_(fd) {
  }

  std::unique_ptr<Server> Build() {
    return std::make_unique<Server>(fd_, services_);
  }

  void RegisterService(Service* service) {
    // TODO(ed): operator[] doesn't accept std::string_view?
    // services_[service->GetName()] = service;
    services_.emplace(service->GetName(), nullptr).first->second = service;
  }

 private:
  const std::shared_ptr<FileDescriptor> fd_;
  std::map<std::string, Service*, std::less<>> services_;
};

class ServerContext {};

// Server-side handle for client-streaming RPCs.
class ServerReaderImpl {
 public:
  explicit ServerReaderImpl(const std::shared_ptr<FileDescriptor>& fd)
      : fd_(fd), finished_(false) {
  }
  ~ServerReaderImpl();

  bool Read(Message* msg);

 private:
  const std::shared_ptr<FileDescriptor> fd_;
  bool finished_;
};

// Type safe wrapper for ServerReaderImpl.
template <typename R>
class ServerReader {
 public:
  explicit ServerReader(ServerReaderImpl* impl) : impl_(impl) {
  }

  bool Read(R* msg) {
    return impl_->Read(msg);
  }

 private:
  ServerReaderImpl* impl_;
};

// Server-side handle for server-streaming RPCs.
class ServerWriterImpl {
 public:
  explicit ServerWriterImpl(const std::shared_ptr<FileDescriptor>& fd)
      : fd_(fd), finished_(false) {
  }

  bool Write(const Message& msg);

 private:
  const std::shared_ptr<FileDescriptor> fd_;
  bool finished_;
};

// Type safe wrapper for ServerWriterImpl.
template <typename W>
class ServerWriter {
 public:
  explicit ServerWriter(ServerWriterImpl* impl) : impl_(impl) {
  }

  bool Write(const W& msg) {
    return impl_->Write(msg);
  }

 private:
  ServerWriterImpl* impl_;
};

}  // namespace arpc

#endif
